java虚拟机规范本身没有规定synchronized该怎么实现

hotspot实现：
jdk1.5之前：
    synchronized 都是重量级锁，也就是每次都要向操作系统申请锁
jdk1.5以后：
    使用锁升级方式
    1、第一个线程访问第一次访问synchronized修饰的方法m1的时候，只是在markwork 上记录这个线程ID ----偏向锁：默认只有一个线程执行
    2、如果线程出现争用（多余一个线程）：发升级为自旋锁，jdk默认自旋10次，占用cpu
    3、如果10次后还没有得到锁：升级为重量级锁。升级为重量级锁后，这个资源就变成等待状态，不占用cpu了
    注：锁只能升级，不能降级。

    问题：什么情况使用自旋锁，什么情况下系统锁？
    加锁代码：执行时间短，线程数较少使用自旋锁；执行时间长，线程数较多使用自旋锁。
    解释：如果执行时间很长的话，那么其他线程自旋10次后，肯定无法获得锁，所以自旋没有意义。如果线程数较多的话，每个线程自旋10次，也会对cpu进行消耗。

    相关文章：没错，我就是厕所所长！(一、二)